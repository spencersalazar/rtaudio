<HTML>
<HEAD>
<TITLE>The RtAudio Home Page</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
<LINK REL="SHORTCUT ICON" HREF="http://www.music.mcgill.ca/~gary/favicon.ico">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<a class="qindex" href="index.html">Home</a> &nbsp; <a class="qindex" href="annotated.html">Class/Enum List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </CENTER>
<HR>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="duplex">Duplex Mode</a></h1>Finally, it is easy to use <a class="el" href="classRtAudio.html">RtAudio</a> for simultaneous audio input/output, or duplex operation. In this example, we simply pass the input data back to the output.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="RtAudio_8h.html">RtAudio.h</a>"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="comment">// Pass-through function.</span>
<span class="keywordtype">int</span> inout( <span class="keywordtype">void</span> *outputBuffer, <span class="keywordtype">void</span> *inputBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nBufferFrames,
           <span class="keywordtype">double</span> streamTime, <a class="code" href="RtAudio_8h.html#a12">RtAudioStreamStatus</a> status, <span class="keywordtype">void</span> *data )
{
  <span class="comment">// Since the number of input and output channels is equal, we can do</span>
  <span class="comment">// a simple buffer copy operation here.</span>
  <span class="keywordflow">if</span> ( status ) std::cout &lt;&lt; <span class="stringliteral">"Stream over/underflow detected."</span> &lt;&lt; std::endl;

  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *bytes = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *) data;
  memcpy( outputBuffer, inputBuffer, *bytes );
  <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span> main()
{
 <a class="code" href="classRtAudio.html">RtAudio</a> adac;
  <span class="keywordflow">if</span> ( adac.<a class="code" href="classRtAudio.html#a3">getDeviceCount</a>() &lt; 1 ) {
    std::cout &lt;&lt; <span class="stringliteral">"\nNo audio devices found!\n"</span>;
    exit( 0 );
  }

  <span class="comment">// Set the same number of channels for both input and output.</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufferBytes, bufferFrames = 512;
  <a class="code" href="structRtAudio_1_1StreamParameters.html">RtAudio::StreamParameters</a> iParams, oParams;
  iParams.<a class="code" href="structRtAudio_1_1StreamParameters.html#o0">deviceId</a> = 0; <span class="comment">// first available device</span>
  iParams.<a class="code" href="structRtAudio_1_1StreamParameters.html#o1">nChannels</a> = 2;
  oParams.<a class="code" href="structRtAudio_1_1StreamParameters.html#o0">deviceId</a> = 0; <span class="comment">// first available device</span>
  oParams.<a class="code" href="structRtAudio_1_1StreamParameters.html#o1">nChannels</a> = 2;

  <span class="keywordflow">try</span> {
    adac.<a class="code" href="classRtAudio.html#a7">openStream</a>( &amp;oParams, &amp;iParams, RTAUDIO_SINT32, 44100, &amp;bufferFrames, &amp;inout, (<span class="keywordtype">void</span> *)&amp;bufferBytes );
  }
  <span class="keywordflow">catch</span> ( <a class="code" href="classRtError.html">RtError</a>&amp; e ) {
    e.<a class="code" href="classRtError.html#a2">printMessage</a>();
    exit( 0 );
  }

  bufferBytes = bufferFrames * 2 * 4;

  <span class="keywordflow">try</span> {
    adac.<a class="code" href="classRtAudio.html#a9">startStream</a>();

    <span class="keywordtype">char</span> input;
    std::cout &lt;&lt; <span class="stringliteral">"\nRunning ... press &lt;enter&gt; to quit.\n"</span>;
    std::cin.get(input);

    <span class="comment">// Stop the stream.</span>
    adac.<a class="code" href="classRtAudio.html#a10">stopStream</a>();
  }
  <span class="keywordflow">catch</span> ( <a class="code" href="classRtError.html">RtError</a>&amp; e ) {
    e.<a class="code" href="classRtError.html#a2">printMessage</a>();
    <span class="keywordflow">goto</span> cleanup;
  }

 cleanup:
  <span class="keywordflow">if</span> ( adac.<a class="code" href="classRtAudio.html#a12">isStreamOpen</a>() ) adac.<a class="code" href="classRtAudio.html#a8">closeStream</a>();

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
In this example, audio recorded by the stream input will be played out during the next round of audio processing.<p>
Note that a duplex stream can make use of two different devices (except when using the Linux Jack and Windows ASIO APIs). However, this may cause timing problems due to possible device clock variations, unless a common external "sync" is provided. <HR>

<table><tr><td><img src="../images/mcgill.gif" width=165></td>
  <td>&copy;2001-2007 Gary P. Scavone, McGill University. All Rights Reserved.<br>Maintained by <a href="http://www.music.mcgill.ca/~gary/">Gary P. Scavone</a>.</td></tr>
</table>

</BODY>
</HTML>
