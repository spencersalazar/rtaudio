<HTML>
<HEAD>
<TITLE>The RtAudio Home Page</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
<LINK REL="SHORTCUT ICON" HREF="http://www.music.mcgill.ca/~gary/favicon.ico">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<a class="qindex" href="index.html">Home</a> &nbsp; <a class="qindex" href="annotated.html">Class/Enum List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </CENTER>
<HR>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="settings">Device Settings</a></h1>The next step in using <a class="el" href="classRtAudio.html">RtAudio</a> is to open a stream with particular device and parameter settings.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="RtAudio_8h.html">RtAudio.h</a>"</span>

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classRtAudio.html">RtAudio</a> dac;
  <span class="keywordflow">if</span> ( dac.<a class="code" href="classRtAudio.html#a3">getDeviceCount</a>() == 0 ) exit( 0 );

  <a class="code" href="structRtAudio_1_1StreamParameters.html">RtAudio::StreamParameters</a> parameters;
  parameters.<a class="code" href="structRtAudio_1_1StreamParameters.html#o0">deviceId</a> = dac.<a class="code" href="classRtAudio.html#a5">getDefaultOutputDevice</a>();
  parameters.<a class="code" href="structRtAudio_1_1StreamParameters.html#o1">nChannels</a> = 2;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sampleRate = 44100;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufferFrames = 256; <span class="comment">// 256 sample frames</span>

  <a class="code" href="structRtAudio_1_1StreamOptions.html">RtAudio::StreamOptions</a> options;
  options.<a class="code" href="structRtAudio_1_1StreamOptions.html#o0">flags</a> = RTAUDIO_NONINTERLEAVED;

  <span class="keywordflow">try</span> {
    dac.<a class="code" href="classRtAudio.html#a7">openStream</a>( &amp;parameters, NULL, RTAUDIO_FLOAT32,
                    sampleRate, &amp;bufferFrames, &amp;myCallback, NULL, &amp;options );
  }
  <span class="keywordflow">catch</span> ( <a class="code" href="classRtError.html">RtError</a>&amp; e ) {
    std::cout &lt;&lt; <span class="charliteral">'\n'</span> &lt;&lt; e.<a class="code" href="classRtError.html#a4">getMessage</a>() &lt;&lt; <span class="charliteral">'\n'</span> &lt;&lt; std::endl;
    exit( 0 );
  }
  
  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
The <a class="el" href="classRtAudio.html#a7">RtAudio::openStream()</a> function attempts to open a stream with a specified set of parameter values. In the above example, we attempt to open a two channel playback stream using the default output device, 32-bit floating point data, a sample rate of 44100 Hz, and a frame rate of 256 sample frames per output buffer. If the user specifies an invalid parameter value (such as a device id greater than or equal to the number of enumerated devices), an <a class="el" href="classRtError.html">RtError</a> is thrown of type = INVALID_USE. If a system error occurs or the device does not support the specified parameter values, an <a class="el" href="classRtError.html">RtError</a> of type = SYSTEM_ERROR is thrown. In either case, a descriptive error message is bundled with the exception and can be queried with the <a class="el" href="classRtError.html#a4">RtError::getMessage()</a> or <a class="el" href="classRtError.html#a5">RtError::what()</a> functions.<p>
<a class="el" href="classRtAudio.html">RtAudio</a> provides four signed integer and two floating point data formats which can be specified using the RtAudioFormat parameter values mentioned earlier. If the opened device does not natively support the given format, <a class="el" href="classRtAudio.html">RtAudio</a> will automatically perform the necessary data format conversion.<p>
The <code>bufferFrames</code> parameter specifies the desired number of sample frames that will be written to and/or read from a device per write/read operation. This parameter can be used to control stream latency though there is no guarantee that the passed value will be that used by a device. In general, a lower <code>bufferFrames</code> value will produce less latency but perhaps less robust performance. A value of zero can be specified, in which case the smallest allowable value will be used. The <code>bufferFrames</code> parameter is passed as a pointer and the actual value used by the stream is set during the device setup procedure. <code>bufferFrames</code> values should be a power of two. Optimal and allowable buffer values tend to vary between systems and devices. Stream latency can also be controlled via the optional <a class="el" href="structRtAudio_1_1StreamOptions.html">RtAudio::StreamOptions</a> member <code>numberOfBuffers</code> (not used in the example above), though this tends to be more system dependent. In particular, the <code>numberOfBuffers</code> parameter is ignored when using the OS-X Core Audio, Jack, and the Windows ASIO APIs.<p>
As noted earlier, the device capabilities reported by a driver or underlying audio API are not always accurate and/or may be dependent on a combination of device settings. Because of this, <a class="el" href="classRtAudio.html">RtAudio</a> does not attempt to query a device's capabilities or use previously reported values when opening a device. Instead, <a class="el" href="classRtAudio.html">RtAudio</a> simply attempts to set the given parameters on a specified device and then checks whether the setup is successful or not.<p>
The RtAudioCallback parameter above is a pointer to a user-defined function that will be called whenever the audio system is ready for new output data or has new input data to be read. Further details on the use of a callback function are provided in the next section.<p>
Several stream options are available to fine-tune the behavior of an audio stream. In the example above, we specify that data will be written by the user in a <em>non-interleaved</em> format via the <a class="el" href="structRtAudio_1_1StreamOptions.html">RtAudio::StreamOptions</a> member <code>flags</code>. That is, all <code>bufferFrames</code> of the first channel should be written consecutively, followed by all <code>bufferFrames</code> of the second channel. By default (when no option is specified), <a class="el" href="classRtAudio.html">RtAudio</a> expects data to be written in an <em>interleaved</em> format. <HR>

<table><tr><td><img src="../images/mcgill.gif" width=165></td>
  <td>&copy;2001-2007 Gary P. Scavone, McGill University. All Rights Reserved.<br>Maintained by <a href="http://www.music.mcgill.ca/~gary/">Gary P. Scavone</a>.</td></tr>
</table>

</BODY>
</HTML>
